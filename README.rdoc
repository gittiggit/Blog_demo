== README

This README would normally document whatever steps are necessary to get the
application up and running.

Things you may want to cover:

* Ruby version

* System dependencies

* Configuration

* Database creation

* Database initialization

* How to run the test suite

* Services (job queues, cache servers, search engines, etc.)

* Deployment instructions

* ...


Please feel free to use a different markup language if you do not plan to run
<tt>rake doc:app</tt>.
======================================================
======================================================
*** To reload the console
=> reload!
=> article = Article.create()
=> article.errors.any?
=> article.errors.full_messages
+++++++++++++++++++++++++++++++++++++
**To deal with model back form(the form that have a model) rails provides form_for method. 

#render plain: params[:article].inspect


+++++++++++++++++++++++++++++++++++++++++++++++++++
** Perform the Article crud 
+++++++++++++++++++++++++++++++++++++++++++++++++++
01. first in the gemfile, include the following lines
gem 'bootstrap-sass', '~> 3.3.6'
gem 'sass-rails', '>= 3.2'
02. then run bundle install
03. Create a assets/stylessheets/custom.css.scss
04. Add the following line at the top of this file
@import "bootstrap-sprockets";
@import "bootstrap";
05. In the assets/javascripts/application.js
include the following line 
//= require bootstrap-sprockets
like as follows:
//= require jquery
//= require jquery_ujs
//= require bootstrap-sprockets
//= require turbolinks
//= require_tree .

++++++++++++++++++++++++++++++++++++++++++++++++
** Add the _navigation.html.erb
** Design the home page
** Add the _footer.html.erb
** Add the design for the footer in the custom css and follow the drive docs

=================================================================
** Now style the form:
** Style the errors partial
** Style the messages partial
** Style the show page of the article
** Style the index page
================================================================
Step 13: Create user
rails g model create User username:string email:string
user = User.find(2)

====================================================================

Step 14: Validates for user model:
 -user name must be present
 -email must be present and unique
 -validate email format using regex
===================================================================

Step 15: generate migration to add user_id column to article
rails g migration add_user_id_to_articles user_id:integer
rake db:migrate

==================================================================
** Article belongs to a user and a user has many articles

u = User.create(username: "Mahmud", email:"m@gmail.com")
ar = Article.create(title:"A title", description:"Some description", user: u)
ar1 = Article.create(title:"A title", description:"Some description", user: u)
ar2 = Article.create(title:"A title", description:"Some description", user: u)

Now if I run the command
u.articles  (because a user may have many articles)
It will give me all the articles belongs to a user u. But if I want to get the user that has the article ar, I have to run the command
ar.user  (not ar.users because an article belong to a user)

Now you want to know about the username who have the article ar1, you have to run the command
ar1.user.username or to get the email (not users)
ar1.user.email (not users)

Now think differently. You need to have all the article's title that belong to a user u. To do this first you have to get all the
articles(as a collection) associated with a user by this command u.articles and then run a loop through them to extract the title
like as follows
u.articles.each do |ar|
    ar.title
end

=====================================================================================
Step 16: Add a debugger to the application.html.er

<%= debug(params) if Rails.env.development? %>

=======================================================================================

Step 17: using hs_secure_password
  a. install the gem "gem 'bcrypt', '~> 3.1.7'"
  b. add this in the user.rb "has_secure_password"
  c. generate a migration to add the password_digest column to the users tabls
     rails g migration add_password_digest_to_users password_digest:string     and the rake db:migrate
  d.  u = User.last
  u.authenticate("password")
  Here authenticate method returns the u if password is matched else return false

==================================================================================
Step 17: named route for user signup: in the routes.rb
get "signup", to: "users#new"

Add the users controller
rails g controller Users index new edit show

** To handle the post request or form submission for create user, in the routes.rb
 post "users", to: "users#create"
 or
 resources :users
 *** Observe the code,
 	resources :users, except:[:new] # because there is a named route for the user/new
 	get "signup", to: "users#new"

 ***
====================================================================================
Step 18: edit user, create _form.html.erb partial for edit and new
         and in the form partial to change the text for the submit button dynamically
         <div class="form-group">
            <div class="col-sm-offset-2 col-sm-10">
              <%= u.submit(@user.new_record? ? "Signup" : "Update account", class:"btn btn-primary btn-lg") %>
            </div>
         </div>

================================================================================
Step 19 : Add the gravatar for the user(follow the drive docs) in the users/show.html.erb
          show all the articles associated with a user. Here I used used the articles/article partial for this purpose
          by passing the object to this partial

==============================================================================================
Step 20 : index all the user and inthe article show, add the gravator of the article creator and his number of article

=========================================

Step 21: Adding pagination
    a. install the gem
    gem "will_paginate", "3.0.7"
    gem "bootstrap-will_paginate", "0.0.10"

    b. In the users controllers index action
    def index
    		@users = User.paginate(page: params[:page], per_page: 2)
      end

    c. In the users/index.html.erb
      <div align="center">
        <%= will_paginate %>
      </div>

    d. To paginate all the articles of a user in the users/show page, first you have to grav all the articles
      associate with a user in the users controler's show action and then use it in the users show view like as follows
      in the users' controller
      def show
      		@user = User.find params[:id]
      		@user_articles = @user.articles.paginate(page: params[:page], per_page: 2)
      end

      In the users/show
        <div align="center">
          <%= will_paginate @user_articles %>
        </div>
          <%= render "articles/article", obj: @user_articles %>
        <div align="center">
          <%= will_paginate @user_articles %>
        </div>

========================================================================
Step 22: User login
      a.Create a session controller
rails g controller Sessions new
 in the routes.rb
 get "login", to: "sessions#new"
 	get "signout", to: "sessions#destroy"
 	resources :sessions, only:[:create]

 in the sessions/new.html.erb
 	-----------------------------------

 	<h1 align="center">Log in</h1>
    <%= form_for(:session, html: {class:"form-horizontal", role: "form"}, url: login_path) do |u| %>
        <div class="form-group">
          <div class="control-label col-sm-2">
            <%= u.label :email %>
          </div>
          <div class="col-sm-8">
            <%= u.email_field :email, class: "form-control", placeholder: "Enter you email", autofocus: true %>
          </div>
        </div>
        <div class="form-group">
          <div class="control-label col-sm-2">
            <%= u.label :password %>
          </div>
          <div class="col-sm-8">
            <%= u.password_field :password, class: "form-control", placeholder: "Enter password", autofocus: true  %>
          </div>
        </div>
        <div class="form-group">
          <div class="col-sm-offset-2 col-sm-10">
            <%= u.submit class:"btn btn-primary btn-lg" %>
          </div>
        </div>
    <% end %>
    <div class="col-xs-12 col-xs-offset-5">
      <%= link_to "[Cancel request and back to article listing]", articles_path %>
    </div>

------------------------------------------------------
Step 23: Session create and destroy using sessions controller Here observe the code,
 <%= form_for(:session, html: {class:"form-horizontal", role: "form"}, url: login_path) do |u| %>
 ** Here this form is not a model back form. Here we are creating a form for the session controller and specifying a url for it. We need to keep
 the information in a session variable in the create action of the session controller, when the user submit the form. And we will take the value
 from the params hash like as follows
 params[:session][:email]
 or
 params[:session][:password]

 -------------------------------
 Another thing to know, follow the codes in the routes.rb
 	get "login", to: "sessions#new"
 	post "login", to: "sessions#create"
 	delete "signout", to: "sessions#destroy"
 Here we are not using resourceful route, because sessions controller in not a model back controller. And observe the code for the
 	post and delete
 	In the sessions/new
 	<%= form_for(:session, html: {class:"form-horizontal", role: "form"}, url: login_path) do |u| %>
 	In the logout link
 	 <li><%= link_to "Log out",signout_path, method: :delete %></li>
 Here we have no object to send and it different from deleting an object from the database like as follows
 	 <li><%= link_to "Delete", article_path(article_object), method: :delete %></li>
 	 <li><%= link_to "Delete", article_path, method: :delete %></li>
 ===================================================================================================

Step 24: Let's know something. The methods we create in our application controller are available to all of our controller. But thery are not
         available to our views by-default. If we want to use them in our views, then we have to tell the rails that, these are helper methods.


























------------------------------------------------------------------------
"hello"   #-> this is a string; it is not in a boolean context
!"hello"  #-> this is a string that is forced into a boolean
          #   context (true), and then negated (false)
!!"hello" #-> this is a string that is forced into a boolean
          #   context (true), and then negated (false), and then
          #   negated again (true)
!!nil     #-> this is a false-y value that is forced into a boolean
          #   context (false), and then negated (true), and then
          #   negated again (false)
In your example, the signed_in? method should return a boolean value (as indicated by convention by the ? character).
The internal logic it uses to decide this value is by checking to see if the current_user variable is set. If it is set,
it will evaluate to true in a boolean context. If not, it will evaluate as false. The double negation forces the return
value to be a boolean.


